<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"> 
    <script type="text/javascript">
      //all this first bit is to make touch events work like mouse events
      //so slider() can be triggered by simple onmouseup
      function touchHandler(event)
      {
          var touches = event.changedTouches,
              first = touches[0],
              type = "";
               switch(event.type)
          {
              case "touchstart": type = "mousedown"; break;
              case "touchmove":  type = "mousemove"; break;        
              case "touchend":   type = "mouseup"; break;
              default: return;
          }

          var simulatedEvent = document.createEvent("MouseEvent");
          simulatedEvent.initMouseEvent(type, true, true, window, 1, 
                 first.screenX, first.screenY, first.clientX, first.clientY,
                 false, false, false, false, 0/*left*/, null);

          first.target.dispatchEvent(simulatedEvent);
          event.preventDefault();
      }

      function init() 
      {
          document.addEventListener("touchstart", touchHandler, true);
          document.addEventListener("touchmove", touchHandler, true);
          document.addEventListener("touchend", touchHandler, true);
          document.addEventListener("touchcancel", touchHandler, true);    
      }
      
      function slider(index)
      {
          var this_val = document.getElementById("val" + index);
          var val = parseInt(document.getElementById(index).value);
          if (val > 100 || val < 0) return false;
          
          this_val.innerHTML = val;
          //XMLHttpRequest done here
          var msg = {};
          msg[index] = val;
          var jsonMsg = JSON.stringify(msg);
          xmlhttp = new XMLHttpRequest();
          xmlhttp.open("GET","/update/?msg=" + jsonMsg, false);
          xmlhttp.send();
          var myObject = JSON.parse(xmlhttp.responseText);
          for (var key in myObject) {
            elmnt = document.getElementById(key)
            if (elmnt) {
              elmnt.value = myObject[key];
            }
          }
      }

      //Convert HSV representation to RGB, may use this if colour mixing
      //is included TODO do we need to feed colours back to contoller?
      //Credits to http://www.raphaeljs.com
      function hsv2rgb(hue, sat, val) {
          var R, G, B, X, C;
          var h = (hue % 360) / 60;
          
          C = val * sat;
          X = C * (1 - Math.abs(h % 2 - 1));
          R = G = B = val - C;

          h = Math.floor(h);
          R += [C, X, 0, 0, X, C][h];
          G += [X, C, C, X, 0, 0][h];
          B += [0, 0, X, C, C, X][h];

          return [R, G, B];
      }
    </script>
    <style>
      <!-- or whatever -->
      .controls{
          width:75%;
          height:2%;
          padding:0 5px;
      }
      .background {
          width:100%;
      }
    </style>
  </head>
  <body onload="init()">
    <div class="background">
      <input type="range" id="f_scale" class="controls" value="50" min="0" max="100" maxlength="3" onmouseup="slider('f_scale')"><span id="valf_scale">0</span><br />
      <input type="range" id="f_spin" class="controls" value="50" min="0" max="100" maxlength="3" onmouseup="slider('f_spin')"><span id="valf_spin">0</span><br />
      <input type="range" id="f_speed" class="controls" value="50" min="0" max="100" maxlength="3" onmouseup="slider('f_speed')"><span id="valf_speed">0</span>
      <!-- etc etc -->
    </div>
  </body>
</html>
